#!/usr/bin/env rdmd
module Bin2D;
import std.file;
import std.stdio : writeln;
import std.string;
import uni = std.uni;
import std.conv : text;

int main(string[] args) {
	string by = "// Generated by Bin2D\n";
	by ~= "// Using command: Bin2D ";
	if (args.length > 2) {
		string output = args[1];
		string modul = "";
		if (output.indexOf("=") > 0) {
			modul = output[output.indexOf("=") + 1 .. $];
			output = output[0 .. output.indexOf("=")];
			by ~= output ~ "=" ~ modul;
		} else {
			by ~= output;
		}

		string[] files;
		foreach (file; args[2..$]) {
			if (exists(file)) {
				if (isFile(file))
					files ~= file;
				else if (isDir(file))
					foreach (entry; dirEntries(file, SpanMode.breadth)) {
						if (isFile(entry))
							files ~= entry;
					}
			}
			by ~= " " ~ file;
		}
		string[] filenames;
		foreach(file; files){
			string t = file;
			if (lastIndexOf(t, "/") > 0)
				t = t[lastIndexOf(t, "/") + 1.. $];
			if (lastIndexOf(t, "\\") > 0)
				t = t[lastIndexOf(t, "\\") + 1 .. $];
			t = t.replace(".", "_");
			filenames ~= t;
		}
		if (exists(output)) {
			if (isFile(output)) {
				remove(output);
			} else if (isDir(output)){
				writeln("Output file is a directory!");
				return 2;
			}
		}
		ubyte[] buffer;
		buffer ~= cast(ubyte[]) by;

		if (modul != "") {
			buffer ~= "\nmodule " ~ modul ~ ";\n";
			buffer ~= """
import std.file : write, isDir, exists, mkdirRecurse, rmdirRecurse, tempDir;
import std.path : buildPath;
import std.process : thisProcessID;
import std.conv : text;

string[string] outputBin2D2FS() {
	return outputBin2D2FS(buildPath(tempDir(), text(thisProcessID())));
}

string[string] outputBin2D2FS(string dir)
in {
	if (exists(dir)) {
		if (isDir(dir)) {
			rmdirRecurse(dir);
			mkdirRecurse(dir);
		} else {
			mkdirRecurse(dir);
		}
	} else {
		mkdirRecurse(dir);
	}
} body {
	uint i;
	string[string] files;
	foreach(name; assetNames) {
		char[] realname = cast(char[])name;
		for(uint j = name.length - 1; j > name.length-5 && j >= 0; j--) {
			if (realname[j] == '_') {
				realname[j] = '.';
				break;
			}
		}
		files[cast(string)realname] ~= cast(string)buildPath(dir, realname);
		write(buildPath(dir, realname), *assetValues[i]);
		i++;
	}
	return files;
}
""";
		} else
			buffer ~= "\n";

		buffer ~= "\nconst string[] assetNames = [";
		foreach(name; filenames) {
			buffer ~= "\"" ~ name ~ "\", ";
		}

		buffer[$-2 .. $] = cast(ubyte[])"];";

		buffer ~= "\nconst(ubyte[])*[] assetValues = [";
		foreach(name; filenames) {
			buffer ~= "&" ~ name ~ ", ";
		}
		buffer[$-2 .. $] = cast(ubyte[])"];";

		for(int i=0; i<files.length; i++) {
			auto file = files[i];
			bool first = true;	
			buffer ~= cast(ubyte[])("\nconst ubyte[] " ~ filenames[i] ~ " = [");
			foreach(b; cast(ubyte[]) read(file)) {
				if (!first)
					buffer ~= cast(byte[])", ";
				buffer ~= cast(ubyte[])format("0x%x", b);
				first = false;
			}
			buffer ~= "];";			
		}
		write(output, buffer);
		
		return 0;
	} else {
		writeln("""Usage: Bin2D <output file>[=<module name>] <files or directories...>
Bin2D is a resource compiler for the D programming language.
It compiles resources down to D source code.
For inclusion into a build. Later accessible given an optional module name.
""");
		return 1;
	}
}

string replace(string text, string oldText, string newText, bool caseSensitive = true, bool first = false) {
	string ret;
	string tempData;
	bool stop;
	foreach(char c; text) {
		if (tempData.length > oldText.length && !stop) {
			ret ~= tempData;
			tempData = "";
		}
		if (((oldText[0 .. tempData.length] != tempData && caseSensitive) || (oldText[0 .. tempData.length].toLower() != tempData.toLower() && !caseSensitive)) && !stop) {
			ret ~= tempData;
			tempData = "";
		}
		tempData ~= c;
		if (((tempData == oldText && caseSensitive) || (tempData.toLower() == oldText.toLower() && !caseSensitive)) && !stop) {
			ret ~= newText;
			tempData = "";
			stop = first;
		}
	}
	if (tempData != "") {
		ret ~= tempData;	
	}
	return ret;
}